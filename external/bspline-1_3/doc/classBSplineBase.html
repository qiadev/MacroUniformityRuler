<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BSpline Library: BSplineBase&lt; T &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>BSplineBase&lt; T &gt; Class Template Reference</h1>The base class for a spline object containing the nodes for a given domain, cutoff wavelength, and boundary condition.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="BSpline_8h-source.html">BSpline.h</a>&gt;</code>
<p>
<p>Inheritance diagram for BSplineBase&lt; T &gt;:
<p><center><img src="classBSplineBase.png" usemap="#BSplineBase< T >_map" border="0" alt=""></center>
<map name="BSplineBase< T >_map">
<area href="classBSpline.html" alt="BSpline< T >" shape="rect" coords="0,56,114,80">
</map>
<a href="classBSplineBase-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="w0" doxytag="BSplineBase::datum_type"></a>
typedef T&nbsp;</td><td class="memItemRight" valign="bottom"><b>datum_type</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#w4">BoundaryConditionTypes</a> { <a class="el" href="classBSplineBase.html#w4w1">BC_ZERO_ENDPOINTS</a> =  0, 
<a class="el" href="classBSplineBase.html#w4w2">BC_ZERO_FIRST</a> =  1, 
<a class="el" href="classBSplineBase.html#w4w3">BC_ZERO_SECOND</a> =  2
 }</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Boundary condition types.  <a href="classBSplineBase.html#w4">More...</a><br></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a0">BSplineBase</a> (const T *x, int nx, double wl, int bc_type=BC_ZERO_SECOND, int num_nodes=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Construct a spline domain for the given set of x values, cutoff wavelength, and boundary condition type.  <a href="#a0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a1" doxytag="BSplineBase::BSplineBase"></a>
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a1">BSplineBase</a> (const <a class="el" href="classBSplineBase.html">BSplineBase</a> &amp;)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Copy constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a2">setDomain</a> (const T *x, int nx, double wl, int bc_type=BC_ZERO_SECOND, int num_nodes=0)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Change the domain of this base.  <a href="#a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="el" href="classBSpline.html">BSpline</a>&lt; T &gt; *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a3">apply</a> (const T *y)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create a <a class="el" href="classBSpline.html">BSpline</a> smoothed curve for the given set of NX y values.  <a href="#a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">const T *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a4">nodes</a> (int *nnodes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return array of the node coordinates.  <a href="#a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a5" doxytag="BSplineBase::nNodes"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a5">nNodes</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the number of nodes (one more than the number of intervals). <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6" doxytag="BSplineBase::nX"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a6">nX</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of original x values. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a7" doxytag="BSplineBase::Xmin"></a>
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a7">Xmin</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Minimum x value found. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a8" doxytag="BSplineBase::Xmax"></a>
T&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a8">Xmax</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Maximum x value found. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a9">Alpha</a> (double wavelength)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the Alpha value for a given wavelength.  <a href="#a9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a10" doxytag="BSplineBase::Alpha"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a10">Alpha</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return alpha currently in use by this domain. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#a11">ok</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the current state of the object, either ok or not ok.  <a href="#a11"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e0" doxytag="BSplineBase::ImplVersion"></a>
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#e0">ImplVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing the implementation version. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="e1" doxytag="BSplineBase::IfaceVersion"></a>
static const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#e1">IfaceVersion</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return a string describing the interface version. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBSplineBase.html#e2">Debug</a> (int on=-1)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Call this class method with a value greater than zero to enable debug messages, or with zero to disable messages.  <a href="#e2"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Protected Types</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="x0" doxytag="BSplineBase::Base"></a>
typedef BSplineBaseP&lt; T &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><b>Base</b></td></tr>

<tr><td colspan="2"><br><h2>Protected Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b0" doxytag="BSplineBase::Setup"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>Setup</b> (int num_nodes=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b1" doxytag="BSplineBase::calculateQ"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>calculateQ</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b2" doxytag="BSplineBase::qDelta"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>qDelta</b> (int m1, int m2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3" doxytag="BSplineBase::Beta"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>Beta</b> (int m)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b4" doxytag="BSplineBase::addP"></a>
void&nbsp;</td><td class="memItemRight" valign="bottom"><b>addP</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b5" doxytag="BSplineBase::factor"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>factor</b> ()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6" doxytag="BSplineBase::Basis"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>Basis</b> (int m, T x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b7" doxytag="BSplineBase::DBasis"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>DBasis</b> (int m, T x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b8" doxytag="BSplineBase::Ratiod"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>Ratiod</b> (int &amp;, double &amp;, double &amp;)</td></tr>

<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p0" doxytag="BSplineBase::waveLength"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>waveLength</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p1" doxytag="BSplineBase::NX"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>NX</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p2" doxytag="BSplineBase::K"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>K</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p3" doxytag="BSplineBase::BC"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>BC</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p4" doxytag="BSplineBase::xmax"></a>
T&nbsp;</td><td class="memItemRight" valign="bottom"><b>xmax</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p5" doxytag="BSplineBase::xmin"></a>
T&nbsp;</td><td class="memItemRight" valign="bottom"><b>xmin</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p6" doxytag="BSplineBase::M"></a>
int&nbsp;</td><td class="memItemRight" valign="bottom"><b>M</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p7" doxytag="BSplineBase::DX"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>DX</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p8" doxytag="BSplineBase::alpha"></a>
double&nbsp;</td><td class="memItemRight" valign="bottom"><b>alpha</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p9" doxytag="BSplineBase::OK"></a>
bool&nbsp;</td><td class="memItemRight" valign="bottom"><b>OK</b></td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="p10" doxytag="BSplineBase::base"></a>
Base *&nbsp;</td><td class="memItemRight" valign="bottom"><b>base</b></td></tr>

<tr><td colspan="2"><br><h2>Static Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static const double&nbsp;</td><td class="memItemRight" valign="bottom"><b>BoundaryConditions</b> [3][4]</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="t1" doxytag="BSplineBase::PI"></a>
static const double&nbsp;</td><td class="memItemRight" valign="bottom"><b>PI</b> = 3.1415927</td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T&gt;<br>
 class BSplineBase&lt; T &gt;</h3>

The base class for a spline object containing the nodes for a given domain, cutoff wavelength, and boundary condition. 
<p>
To smooth a single curve, the <a class="el" href="classBSpline.html">BSpline</a> interface contains a constructor which both sets up the domain and solves for the spline. Subsequent curves over the same domain can be created by <a class="el" href="classBSplineBase.html#a3">apply()</a>ing them to the <a class="el" href="classBSpline.html">BSpline</a> object, where <a class="el" href="classBSplineBase.html#a3">apply()</a> is a BSplineBase method. [See <a class="el" href="classBSplineBase.html#a3">apply()</a>.] New curves can also be smoothed within the same <a class="el" href="classBSpline.html">BSpline</a> object by calling solve() with the new set of y values. [See <a class="el" href="classBSpline.html">BSpline</a>.] A BSplineBase can be created on its own, in which case all of the computations dependent on the x values, boundary conditions, and cutoff wavelength have already been completed.<p>
The solution of the cubic b-spline is divided into two parts. The first is the setup of the domain given the x values, boundary conditions, and wavelength. The second is the solution of the spline for a set of y values corresponding to the x values in the domain. The first part is done in the creation of the BSplineBase object (or when calling the setDomain method). The second part is done when creating a <a class="el" href="classBSpline.html">BSpline</a> object (or calling solve() on a <a class="el" href="classBSpline.html">BSpline</a> object).<p>
A <a class="el" href="classBSpline.html">BSpline</a> object can be created with either one of its constructors, or by calling <a class="el" href="classBSplineBase.html#a3">apply()</a> on an existing BSplineBase object. Once a spline has been solved, it can be evaluated at any x value. The following example creates a spline curve and evaluates it over the domain:<p>
<div class="fragment"><pre class="fragment">    vector&lt;float&gt; x;
    vector&lt;float&gt; y;
    { ... }
    int bc = BSplineBase&lt;float&gt;::BC_ZERO_SECOND;
    BSpline&lt;float&gt;::Debug = true;
    BSpline&lt;float&gt; spline (x.begin(), x.size(), y.begin(), wl, bc);
    if (spline.ok())
    {
        ostream_iterator&lt;float&gt; of(cout, "\t ");
    	float xi = spline.Xmin();
	float xs = (spline.Xmax() - xi) / 2000.0;
	for (; xi &lt;= spline.Xmax(); xi += xs)
	{
	    *of++ = spline.evaluate (xi);
	}
    }
 
</pre></div><p>
In the usual usage, the BSplineBase can compute a reasonable number of nodes for the spline, balancing between a few desirable factors. There needs to be at least 2 nodes per cutoff wavelength (preferably 4 or more) for the derivative constraint to reliably approximate a lo-pass filter. There should be at least 1 and preferably about 2 data points per node (measured just by their number and not by any check of the density of points across the domain). Lastly, of course, the fewer the nodes then the faster the computation of the spline. The computation of the number of nodes happens in the Setup() method during BSplineBase construction and when <a class="el" href="classBSplineBase.html#a2">setDomain()</a> is called. If the setup fails to find a desirable number of nodes, then the BSplineBase object will return false from <a class="el" href="classBSplineBase.html#a11">ok()</a>.<p>
The <a class="el" href="classBSplineBase.html#a11">ok()</a> method returns false when a BSplineBase or <a class="el" href="classBSpline.html">BSpline</a> could not complete any operation successfully. In particular, as mentioned above, <a class="el" href="classBSplineBase.html#a11">ok()</a> will return false if some problem was detected with the domain values or if no reasonable number of nodes could be found for the given cutoff wavelength. Also, <a class="el" href="classBSplineBase.html#a11">ok()</a> on a <a class="el" href="classBSpline.html">BSpline</a> object will return false if the matrix equation could not be solved, such as after <a class="el" href="classBSpline.html">BSpline</a> construction or after a call to <a class="el" href="classBSplineBase.html#a3">apply()</a>.<p>
If letting Setup() determine the number of nodes is not acceptable, the constructors and <a class="el" href="classBSplineBase.html#a2">setDomain()</a> accept the parameter num_nodes. By default, num_nodes is passed as zero, forcing Setup() to calculate the number of nodes. However, if num_nodes is passed as 2 or greater, then Setup() will bypass its own algorithm and accept the given number of nodes instead. Obviously, it's up to the programmer to understand the affects of the number of nodes on the representation of the data and on the solution (or non-solution) of the spline. Remember to check the <a class="el" href="classBSplineBase.html#a11">ok()</a> method to detect when the spline solution has failed.<p>
The interface for the BSplineBase and <a class="el" href="classBSpline.html">BSpline</a> templates is defined in the header file <a class="el" href="BSpline_8h.html">BSpline.h</a>. The implementation is defined in <a class="el" href="BSpline_8cpp.html">BSpline.cpp</a>. Source files which will instantiate the template should include the implementation file and <em>not</em> the interface. If the implementation for a specific type will be linked from elsewhere, such as a static library or Windows DLL, source files should only include the interface file. On Windows, applications should link with the import library BSpline.lib and make sure BSpline.dll is on the path. The DLL contains an implementation for BSpline&lt;float&gt; and BSpline&lt;double&gt;. For debugging, an application can include the implementation to get its own instantiation.<p>
The algorithm is based on the cubic spline described by Katsuyuki Ooyama in Montly Weather Review, Vol 115, October 1987. This implementation has benefited from comparisons with a previous FORTRAN implementation by James L. Franklin, NOAA/Hurricane Research Division. In particular, the algorithm in the Setup() method is based mostly on his implementation (VICSETUP). The Setup() method finds a suitable default for the number of nodes given a domain and cutoff frequency. This implementation adopts most of the same constraints, including a constraint that the cutoff wavelength not be greater than the span of the domain values: wl &lt; max(x) - min(x). If this is not an acceptable constraint, then use the num_nodes parameter to specify the number of nodes explicitly.<p>
The cubic b-spline is formulated as the sum of some multiple of the basis function centered at each node in the domain. The number of nodes is determined by the desired cutoff wavelength and a desirable number of x values per node. The basis function is continuous and differentiable up to the second degree. A derivative constraint is included in the solution to achieve the effect of a low-pass frequency filter with the given cutoff wavelength. The derivative constraint can be disabled by specifying a wavelength value of zero, which reduces the analysis to a least squares fit to a cubic b-spline. The domain nodes, boundary constraints, and wavelength determine a linear system of equations, Qa=b, where a is the vector of basis function coefficients at each node. The coefficient vector is solved by first LU factoring along the diagonally banded matrix Q in BSplineBase. The <a class="el" href="classBSpline.html">BSpline</a> object then computes the B vector for a set of y values and solves for the coefficient vector with the LU matrix. Only the diagonal bands are stored in memory and calculated during LU factoring and back substitution, and the basis function is evaluated as few times as possible in computing the diagonal matrix and B vector.<p>
<dl compact><dt><b>Author:</b></dt><dd>Gary Granger (<a href="http://www.atd.ucar.edu/~granger">http://www.atd.ucar.edu/~granger</a>)</dd></dl>
<div class="fragment"><pre class="fragment">Copyright (c) 1998-2003
University Corporation for Atmospheric Research, UCAR
</pre></div> 
<p>
<hr><h2>Member Enumeration Documentation</h2>
<a class="anchor" name="w4" doxytag="BSplineBase::BoundaryConditionTypes"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">enum <a class="el" href="classBSplineBase.html#w4">BSplineBase::BoundaryConditionTypes</a>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Boundary condition types. 
<p>
<dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="w4w1" doxytag="BC_ZERO_ENDPOINTS"></a>BC_ZERO_ENDPOINTS</em>&nbsp;</td><td>
Set the endpoints of the spline to zero. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="w4w2" doxytag="BC_ZERO_FIRST"></a>BC_ZERO_FIRST</em>&nbsp;</td><td>
Set the first derivative of the spline to zero at the endpoints. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="w4w3" doxytag="BC_ZERO_SECOND"></a>BC_ZERO_SECOND</em>&nbsp;</td><td>
Set the second derivative to zero. </td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="a0" doxytag="BSplineBase::BSplineBase"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::<a class="el" href="classBSplineBase.html">BSplineBase</a>           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bc_type</em> = <code>BC_ZERO_SECOND</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_nodes</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Construct a spline domain for the given set of x values, cutoff wavelength, and boundary condition type. 
<p>
The parameters are the same as for <a class="el" href="classBSplineBase.html#a2">setDomain()</a>. Call <a class="el" href="classBSplineBase.html#a11">ok()</a> to check whether domain setup succeeded after construction.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="a9" doxytag="BSplineBase::Alpha"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Alpha           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">double&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>wavelength</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the Alpha value for a given wavelength. 
<p>
Note that this depends on the current node interval length (DX).     </td>
  </tr>
</table>
<a class="anchor" name="a3" doxytag="BSplineBase::apply"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"><a class="el" href="classBSpline.html">BSpline</a>&lt; T &gt; * <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::apply           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>y</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a <a class="el" href="classBSpline.html">BSpline</a> smoothed curve for the given set of NX y values. 
<p>
The returned object will need to be deleted by the caller. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>y</em>&nbsp;</td><td>The array of y values corresponding to each of the <a class="el" href="classBSplineBase.html#a6">nX()</a> x values in the domain. </td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classBSplineBase.html#a11">ok()</a> </dd></dl>
    </td>
  </tr>
</table>
<a class="anchor" name="e2" doxytag="BSplineBase::Debug"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::Debug           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>on</em> = <code>-1</code>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline, static]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Call this class method with a value greater than zero to enable debug messages, or with zero to disable messages. 
<p>
Calling with no arguments returns true if debugging enabled, else false.     </td>
  </tr>
</table>
<a class="anchor" name="a4" doxytag="BSplineBase::nodes"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const T * <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::nodes           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">int *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap> <em>nnodes</em>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return array of the node coordinates. 
<p>
Returns 0 if not <a class="el" href="classBSplineBase.html#a11">ok()</a>. The array of nodes returned by <a class="el" href="classBSplineBase.html#a4">nodes()</a> belongs to the object and should not be deleted; it will also be invalid if the object is destroyed.     </td>
  </tr>
</table>
<a class="anchor" name="a11" doxytag="BSplineBase::ok"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::ok           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>          </td>
          <td class="md" valign="top">&nbsp;)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return the current state of the object, either ok or not ok. 
<p>
Use this method to test for valid state after construction or after a call to <a class="el" href="classBSplineBase.html#a2">setDomain()</a>. <a class="el" href="classBSplineBase.html#a11">ok()</a> will return false if either fail, such as when an appropriate number of nodes and node interval cannot be found for a given wavelength, or when the linear equation for the coefficients cannot be solved.     </td>
  </tr>
</table>
<a class="anchor" name="a2" doxytag="BSplineBase::setDomain"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">bool <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::setDomain           </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T *&nbsp;</td>
          <td class="mdname" nowrap> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>nx</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>double&nbsp;</td>
          <td class="mdname" nowrap> <em>wl</em>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>bc_type</em> = <code>BC_ZERO_SECOND</code>, </td>
        </tr>
        <tr>
          <td class="md" nowrap align="right"></td>
          <td class="md"></td>
          <td class="md" nowrap>int&nbsp;</td>
          <td class="mdname" nowrap> <em>num_nodes</em> = <code>0</code></td>
        </tr>
        <tr>
          <td class="md"></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Change the domain of this base. 
<p>
[If this is part of a <a class="el" href="classBSpline.html">BSpline</a> object, this method {<em>will</em> not} change the existing curve or re-apply the smoothing to any set of y values.]<p>
The x values can be in any order, but they must be of sufficient density to support the requested cutoff wavelength. The setup of the domain may fail because of either inconsistency between the x density and the cutoff wavelength, or because the resulting matrix could not be factored. If setup fails, the method returns false.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>x</em>&nbsp;</td><td>The array of x values in the domain. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nx</em>&nbsp;</td><td>The number of values in the <code>x</code> array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wl</em>&nbsp;</td><td>The cutoff wavelength, in the same units as the <code>x</code> values. A wavelength of zero disables the derivative constraint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bc_type</em>&nbsp;</td><td>The enumerated boundary condition type. If omitted it defaults to BC_ZERO_SECOND. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>num_nodes</em>&nbsp;</td><td>The number of nodes to use for the cubic b-spline. If less than 2 a reasonable number will be calculated automatically, if possible, taking into account the given cutoff wavelength.</td></tr>
  </table>
</dl>
<dl compact><dt><b>See also:</b></dt><dd><a class="el" href="classBSplineBase.html#a11">ok()</a>. </dd></dl>
    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="t0" doxytag="BSplineBase::BoundaryConditions"></a><p>
<table class="mdTable" cellpadding="2" cellspacing="0">
  <tr>
    <td class="mdRow">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="mdPrefix" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top">const double <a class="el" href="classBSplineBase.html">BSplineBase</a>&lt; T &gt;::BoundaryConditions<code> [static, protected]</code>          </td>
        </tr>
      </table>
    </td>
  </tr>
</table>
<table cellspacing="5" cellpadding="0" border="0">
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<b>Initial value:</b><div class="fragment"><pre class="fragment"> 
{ 
    
    {   -4,             -1,             -1,             -4 },
    {   0,              1,              1,              0 },
    {   2,              -1,             -1,             2 }
}
</pre></div>    </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li>/code/granger/bspline/bspline-1_3/BSpline/<a class="el" href="BSpline_8h-source.html">BSpline.h</a><li><a class="el" href="BSpline_8cpp.html">BSpline.cpp</a></ul>
<hr size="1"><address style="align: right;"><small>Generated on Tue May 31 13:21:37 2005 for BSpline Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
