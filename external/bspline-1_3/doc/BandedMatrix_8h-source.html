<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>BSpline Library: BandedMatrix.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.2 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>BandedMatrix.h</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/* -*- mode: c++; c-basic-offset: 4; -*-</span>
00002 <span class="comment"> *</span>
00003 <span class="comment"> * Template for a diagonally banded matrix.</span>
00004 <span class="comment"> */</span>
00005 <span class="comment">/*</span>
00006 <span class="comment"> * Copyright (c) 1998,1999</span>
00007 <span class="comment"> * University Corporation for Atmospheric Research, UCAR</span>
00008 <span class="comment"> *</span>
00009 <span class="comment"> * Permission to use, copy, modify, distribute and sell this software and</span>
00010 <span class="comment"> * its documentation for any purpose is hereby granted without fee,</span>
00011 <span class="comment"> * provided that the above copyright notice appear in all copies and that</span>
00012 <span class="comment"> * both that copyright notice and this permission notice appear in</span>
00013 <span class="comment"> * supporting documentation.  UCAR makes no representations about the</span>
00014 <span class="comment"> * suitability of this software for any purpose.  It is provided "as is"</span>
00015 <span class="comment"> * without express or implied warranty.</span>
00016 <span class="comment"> * </span>
00017 <span class="comment"> * Note from the author:</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * Where possible, you are encouraged to follow the GNU General Public</span>
00020 <span class="comment"> * License, or at least the spirit of the license, for the distribution and</span>
00021 <span class="comment"> * licensing of this software and any derived works.  See</span>
00022 <span class="comment"> * http://www.gnu.org/copyleft/gpl.html.</span>
00023 <span class="comment"> */</span>
00024 
00025 <span class="preprocessor">#ifndef _BANDEDMATRIX_ID</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#define _BANDEDMATRIX_ID "$Id: BandedMatrix.h,v 1.14 2005/05/27 21:16:44 granger Exp $"</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#include &lt;vector&gt;</span>
00029 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00030 <span class="preprocessor">#include &lt;iostream&gt;</span>
00031 
00032 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>BandedMatrixRow;
00033 
00034 
00035 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>BandedMatrix
00036 {
00037 <span class="keyword">public</span>:
00038     <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size_type;
00039     <span class="keyword">typedef</span> T element_type;
00040 
00041     <span class="comment">// Create a banded matrix with the same number of bands above and below</span>
00042     <span class="comment">// the diagonal.</span>
00043     BandedMatrix (<span class="keywordtype">int</span> N_ = 1, <span class="keywordtype">int</span> nbands_off_diagonal = 0) : bands(0)
00044     {
00045         <span class="keywordflow">if</span> (! setup (N_, nbands_off_diagonal))
00046             setup ();
00047     }
00048 
00049     <span class="comment">// Create a banded matrix by naming the first and last non-zero bands,</span>
00050     <span class="comment">// where the diagonal is at zero, and bands below the diagonal are</span>
00051     <span class="comment">// negative, bands above the diagonal are positive.</span>
00052     BandedMatrix (<span class="keywordtype">int</span> N_, <span class="keywordtype">int</span> first, <span class="keywordtype">int</span> last) : bands(0)
00053     {
00054         <span class="keywordflow">if</span> (! setup (N_, first, last))
00055             setup ();
00056     }
00057 
00058     <span class="comment">// Copy constructor</span>
00059     BandedMatrix (<span class="keyword">const</span> BandedMatrix &amp;b) : bands(0)
00060     {
00061         Copy (*<span class="keyword">this</span>, b);
00062     }
00063 
00064     <span class="keyword">inline</span> <span class="keywordtype">bool</span> setup (<span class="keywordtype">int</span> N_ = 1, <span class="keywordtype">int</span> noff = 0)
00065     {
00066         <span class="keywordflow">return</span> setup (N_, -noff, noff);
00067     }
00068 
00069     <span class="keywordtype">bool</span> setup (<span class="keywordtype">int</span> N_, <span class="keywordtype">int</span> first, <span class="keywordtype">int</span> last)
00070     {
00071         <span class="comment">// Check our limits first and make sure they make sense.</span>
00072         <span class="comment">// Don't change anything until we know it will work.</span>
00073         <span class="keywordflow">if</span> (first &gt; last || N_ &lt;= 0)
00074             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00075 
00076         <span class="comment">// Need at least as many N_ as columns and as rows in the bands.</span>
00077         <span class="keywordflow">if</span> (N_ &lt; abs(first) || N_ &lt; abs(last))
00078             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00079 
00080         top = last;
00081         bot = first;
00082         N = N_;
00083         out_of_bounds = T();
00084 
00085         <span class="comment">// Finally setup the diagonal vectors</span>
00086         nbands = last - first + 1;
00087         <span class="keywordflow">if</span> (bands) <span class="keyword">delete</span>[] bands;
00088         bands = <span class="keyword">new</span> std::vector&lt;T&gt;[nbands];
00089         <span class="keywordtype">int</span> i;
00090         <span class="keywordflow">for</span> (i = 0; i &lt; nbands; ++i)
00091         {
00092             <span class="comment">// The length of each array varies with its distance from the</span>
00093             <span class="comment">// diagonal</span>
00094             <span class="keywordtype">int</span> len = N - (abs(bot + i));
00095             bands[i].clear ();
00096             bands[i].resize (len);
00097         }
00098         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00099     }
00100 
00101     BandedMatrix&lt;T&gt; &amp; operator= (<span class="keyword">const</span> BandedMatrix&lt;T&gt; &amp;b) 
00102     {
00103         <span class="keywordflow">return</span> Copy (*<span class="keyword">this</span>, b);
00104     }
00105 
00106     BandedMatrix&lt;T&gt; &amp; operator= (<span class="keyword">const</span> T &amp;e)
00107     {
00108         <span class="keywordtype">int</span> i;
00109         <span class="keywordflow">for</span> (i = 0; i &lt; nbands; ++i)
00110         {
00111             std::fill_n (bands[i].begin(), bands[i].size(), e);
00112         }
00113         out_of_bounds = e;
00114         <span class="keywordflow">return</span> (*<span class="keyword">this</span>);
00115     }
00116 
00117     ~BandedMatrix ()
00118     {
00119         <span class="keywordflow">if</span> (bands)
00120             <span class="keyword">delete</span>[] bands;
00121     }
00122 
00123 <span class="keyword">private</span>:
00124     <span class="comment">// Return false if coordinates are out of bounds</span>
00125     <span class="keyword">inline</span> <span class="keywordtype">bool</span> check_bounds (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j, <span class="keywordtype">int</span> &amp;v, <span class="keywordtype">int</span> &amp;e)<span class="keyword"> const</span>
00126 <span class="keyword">    </span>{
00127         v = (j - i) - bot;
00128         e = (i &gt;= j) ? j : i;
00129         <span class="keywordflow">return</span> !(v &lt; 0 || v &gt;= nbands || 
00130                  e &lt; 0 || (unsigned int)e &gt;= bands[v].size());
00131     }
00132 
00133     <span class="keyword">static</span> BandedMatrix &amp; Copy (BandedMatrix &amp;a, <span class="keyword">const</span> BandedMatrix &amp;b)
00134     {
00135         <span class="keywordflow">if</span> (a.bands) <span class="keyword">delete</span>[] a.bands;
00136         a.top = b.top;
00137         a.bot = b.bot;
00138         a.N = b.N;
00139         a.out_of_bounds = b.out_of_bounds;
00140         a.nbands = a.top - a.bot + 1;
00141         a.bands = <span class="keyword">new</span> std::vector&lt;T&gt;[a.nbands];
00142         <span class="keywordtype">int</span> i;
00143         <span class="keywordflow">for</span> (i = 0; i &lt; a.nbands; ++i)
00144         {
00145             a.bands[i] = b.bands[i];
00146         }
00147         <span class="keywordflow">return</span> a;
00148     }
00149 
00150 <span class="keyword">public</span>:
00151     T &amp;element (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)
00152     {
00153         <span class="keywordtype">int</span> v, e;
00154         <span class="keywordflow">if</span> (check_bounds(i, j, v, e))
00155             <span class="keywordflow">return</span> (bands[v][e]);
00156         <span class="keywordflow">else</span>
00157             <span class="keywordflow">return</span> out_of_bounds;
00158     }
00159 
00160     <span class="keyword">const</span> T &amp;element (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)<span class="keyword"> const</span>
00161 <span class="keyword">    </span>{
00162         <span class="keywordtype">int</span> v, e;
00163         <span class="keywordflow">if</span> (check_bounds(i, j, v, e))
00164             <span class="keywordflow">return</span> (bands[v][e]);
00165         <span class="keywordflow">else</span>
00166             <span class="keywordflow">return</span> out_of_bounds;
00167     }
00168 
00169     <span class="keyword">inline</span> T &amp; operator() (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j) 
00170     {
00171         <span class="keywordflow">return</span> element (i-1,j-1);
00172     }
00173 
00174     <span class="keyword">inline</span> <span class="keyword">const</span> T &amp; operator() (<span class="keywordtype">int</span> i, <span class="keywordtype">int</span> j)<span class="keyword"> const</span>
00175 <span class="keyword">    </span>{
00176         <span class="keywordflow">return</span> element (i-1,j-1);
00177     }
00178 
00179     size_type num_rows()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> N; }
00180 
00181     size_type num_cols()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> N; }
00182 
00183     <span class="keyword">const</span> BandedMatrixRow&lt;T&gt; operator[] (<span class="keywordtype">int</span> row)<span class="keyword"> const</span>
00184 <span class="keyword">    </span>{
00185         <span class="keywordflow">return</span> BandedMatrixRow&lt;T&gt;(*<span class="keyword">this</span>, row);
00186     }
00187 
00188     BandedMatrixRow&lt;T&gt; operator[] (<span class="keywordtype">int</span> row)
00189     {
00190         <span class="keywordflow">return</span> BandedMatrixRow&lt;T&gt;(*<span class="keyword">this</span>, row);
00191     }
00192 
00193 
00194 <span class="keyword">private</span>:
00195 
00196     <span class="keywordtype">int</span> top;
00197     <span class="keywordtype">int</span> bot;
00198     <span class="keywordtype">int</span> nbands;
00199     std::vector&lt;T&gt; *bands;
00200     <span class="keywordtype">int</span> N;
00201     T out_of_bounds;
00202 
00203 };
00204 
00205 
00206 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00207 std::ostream &amp;operator&lt;&lt; (std::ostream &amp;out, const BandedMatrix&lt;T&gt; &amp;m)
00208 {
00209     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i, j;
00210     <span class="keywordflow">for</span> (i = 0; i &lt; m.num_rows(); ++i)
00211     {
00212         <span class="keywordflow">for</span> (j = 0; j &lt; m.num_cols(); ++j)
00213         {
00214             out &lt;&lt; m.element (i, j) &lt;&lt; <span class="stringliteral">" "</span>;
00215         }
00216         out &lt;&lt; std::endl;
00217     }
00218     <span class="keywordflow">return</span> out;
00219 }
00220 
00221 
00222 
00223 <span class="comment">/*</span>
00224 <span class="comment"> * Helper class for the intermediate in the [][] operation.</span>
00225 <span class="comment"> */</span>
00226 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt; <span class="keyword">class </span>BandedMatrixRow
00227 {
00228 <span class="keyword">public</span>:
00229     BandedMatrixRow (<span class="keyword">const</span> BandedMatrix&lt;T&gt; &amp;_m, <span class="keywordtype">int</span> _row) : bm(_m), i(_row)
00230     { }
00231 
00232     BandedMatrixRow (BandedMatrix&lt;T&gt; &amp;_m, <span class="keywordtype">int</span> _row) : bm(_m), i(_row)
00233     { }
00234 
00235     ~BandedMatrixRow () {}
00236 
00237     <span class="keyword">typename</span> BandedMatrix&lt;T&gt;::element_type &amp; operator[] (<span class="keywordtype">int</span> j)
00238     {
00239         <span class="keywordflow">return</span> const_cast&lt;BandedMatrix&lt;T&gt; &amp;&gt;(bm).element (i, j);
00240     }
00241 
00242     <span class="keyword">const</span> <span class="keyword">typename</span> BandedMatrix&lt;T&gt;::element_type &amp; operator[] (<span class="keywordtype">int</span> j)<span class="keyword"> const</span>
00243 <span class="keyword">    </span>{
00244         <span class="keywordflow">return</span> bm.element (i, j);
00245     }
00246 
00247 <span class="keyword">private</span>:
00248     <span class="keyword">const</span> BandedMatrix&lt;T&gt; &amp;bm;
00249     <span class="keywordtype">int</span> i;
00250 };
00251 
00252 
00253 <span class="comment">/*</span>
00254 <span class="comment"> * Vector multiplication</span>
00255 <span class="comment"> */</span>
00256 
00257 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Vector, <span class="keyword">class</span> Matrix&gt;
00258 Vector operator* (<span class="keyword">const</span> Matrix &amp;m, <span class="keyword">const</span> Vector &amp;v)
00259 {
00260     <span class="keyword">typename</span> Matrix::size_type M = m.num_rows();
00261     <span class="keyword">typename</span> Matrix::size_type N = m.num_cols();
00262 
00263     assert (N &lt;= v.size());
00264     <span class="comment">//if (M &gt; v.size())</span>
00265     <span class="comment">//  return Vector();</span>
00266 
00267     Vector r(N);
00268     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; M; ++i)
00269     {
00270         <span class="keyword">typename</span> Matrix::element_type sum = 0;
00271         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; N; ++j)
00272         {
00273             sum += m[i][j] * v[j];
00274         }
00275         r[i] = sum;
00276     }
00277     <span class="keywordflow">return</span> r;
00278 }
00279 
00280 
00281 
00282 <span class="comment">/*</span>
00283 <span class="comment"> * LU factor a diagonally banded matrix using Crout's algorithm, but</span>
00284 <span class="comment"> * limiting the trailing sub-matrix multiplication to the non-zero</span>
00285 <span class="comment"> * elements in the diagonal bands.  Return nonzero if a problem occurs.</span>
00286 <span class="comment"> */</span>
00287 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MT&gt;
00288 <span class="keywordtype">int</span> LU_factor_banded (MT &amp;A, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bands)
00289 {
00290     <span class="keyword">typename</span> MT::size_type M = A.num_rows();
00291     <span class="keyword">typename</span> MT::size_type N = A.num_cols();
00292     <span class="keywordflow">if</span> (M != N)
00293         <span class="keywordflow">return</span> 1;
00294 
00295     <span class="keyword">typename</span> MT::size_type i,j,k;
00296     <span class="keyword">typename</span> MT::element_type sum;
00297 
00298     <span class="keywordflow">for</span> (j = 1; j &lt;= N; ++j)
00299     {
00300         <span class="comment">// Check for zero pivot</span>
00301         <span class="keywordflow">if</span> ( A(j,j) == 0 )                 
00302             <span class="keywordflow">return</span> 1;
00303 
00304         <span class="comment">// Calculate rows above and on diagonal. A(1,j) remains as A(1,j).</span>
00305         <span class="keywordflow">for</span> (i = (j &gt; bands) ? j-bands : 1; i &lt;= j; ++i)
00306         {       
00307             sum = 0;
00308             <span class="keywordflow">for</span> (k = (j &gt; bands) ? j-bands : 1; k &lt; i; ++k)
00309             {
00310                 sum += A(i,k)*A(k,j);
00311             }
00312             A(i,j) -= sum;
00313         }
00314 
00315         <span class="comment">// Calculate rows below the diagonal.</span>
00316         <span class="keywordflow">for</span> (i = j+1; (i &lt;= M) &amp;&amp; (i &lt;= j+bands); ++i)
00317         {
00318             sum = 0;
00319             <span class="keywordflow">for</span> (k = (i &gt; bands) ? i-bands : 1; k &lt; j; ++k)
00320             {
00321                 sum += A(i,k)*A(k,j);
00322             }
00323             A(i,j) = (A(i,j) - sum) / A(j,j);
00324         }
00325     }
00326 
00327     <span class="keywordflow">return</span> 0;
00328 }   
00329 
00330 
00331 
00332 <span class="comment">/*</span>
00333 <span class="comment"> * Solving (LU)x = B.  First forward substitute to solve for y, Ly = B.</span>
00334 <span class="comment"> * Then backwards substitute to find x, Ux = y.  Return nonzero if a</span>
00335 <span class="comment"> * problem occurs.  Limit the substitution sums to the elements on the</span>
00336 <span class="comment"> * bands above and below the diagonal.</span>
00337 <span class="comment"> */</span>
00338 <span class="keyword">template</span> &lt;<span class="keyword">class</span> MT, <span class="keyword">class</span> Vector&gt;
00339 <span class="keywordtype">int</span> LU_solve_banded(<span class="keyword">const</span> MT &amp;A, Vector &amp;b, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bands)
00340 {
00341     <span class="keyword">typename</span> MT::size_type i,j;
00342     <span class="keyword">typename</span> MT::size_type M = A.num_rows();
00343     <span class="keyword">typename</span> MT::size_type N = A.num_cols();
00344     <span class="keyword">typename</span> MT::element_type sum;
00345 
00346     <span class="keywordflow">if</span> (M != N || M == 0)
00347         <span class="keywordflow">return</span> 1;
00348 
00349     <span class="comment">// Forward substitution to find y.  The diagonals of the lower</span>
00350     <span class="comment">// triangular matrix are taken to be 1.</span>
00351     <span class="keywordflow">for</span> (i = 2; i &lt;= M; ++i)
00352     {
00353         sum = b[i-1];
00354         <span class="keywordflow">for</span> (j = (i &gt; bands) ? i-bands : 1; j &lt; i; ++j)
00355         {
00356             sum -= A(i,j)*b[j-1];
00357         }
00358         b[i-1] = sum;
00359     }
00360 
00361     <span class="comment">// Now for the backward substitution</span>
00362     b[M-1] /= A(M,M);
00363     <span class="keywordflow">for</span> (i = M-1; i &gt;= 1; --i)
00364     {
00365         <span class="keywordflow">if</span> (A(i,i) == 0)        <span class="comment">// oops!</span>
00366             <span class="keywordflow">return</span> 1;
00367         sum = b[i-1];
00368         <span class="keywordflow">for</span> (j = i+1; (j &lt;= N) &amp;&amp; (j &lt;= i+bands); ++j)
00369         {
00370             sum -= A(i,j)*b[j-1];
00371         }
00372         b[i-1] = sum / A(i,i);
00373     }
00374 
00375     <span class="keywordflow">return</span> 0;
00376 }
00377 
00378 
00379 <span class="preprocessor">#endif </span><span class="comment">/* _BANDEDMATRIX_ID */</span>
00380 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue May 31 13:21:37 2005 for BSpline Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.2 </small></address>
</body>
</html>
